{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to my personal notes</p>"},{"location":"languages-and-frameworks/","title":"Welcome","text":""},{"location":"languages-and-frameworks/java/Intro/","title":"Java Notes","text":"<p>TBD</p>"},{"location":"languages-and-frameworks/linting-formatting/intro/","title":"Intro","text":"<p>For automatic linting and formatting, we will be using: (test)[vf]</p> <ul> <li>ESLint</li> <li>Prettier[https://prettier.io/]</li> <li>Husky[https://typicode.github.io/husky/#/]</li> <li>lint-staged[https://github.com/okonet/lint-staged#why]</li> </ul> <p>There\u2019s many code quality tools out there for TypeScript, but ESLint and Prettier are two of the most popular and well supported ones</p> <p>What\u2019s the difference between Prettier and ESLint?</p> <pre><code>Linters have two categories of rules:\n\nFormatting rules: eg: max-len, no-mixed-spaces-and-tabs, keyword-spacing, comma-style\u2026\n\nPrettier alleviates the need for this whole category of rules! Prettier is going to reprint the entire program from scratch in a consistent way, so it\u2019s not possible for the programmer to make a mistake there anymore :)\n\nCode-quality rules: eg no-unused-vars, no-extra-bind, no-implicit-globals, prefer-promise-reject-errors\u2026\n\nPrettier does nothing to help with those kind of rules. They are also the most important ones provided by linters as they are likely to catch real bugs with your code!\n\nIn other words, use Prettier for formatting and linters for catching bugs!\n</code></pre> <p>When you start, your package.json file\u2019s scripts and devDependencies blocks may look like this. <pre><code>{\n\"scripts\": {\n\"clean\": \"rm -rf dist &amp;&amp; rm -rf cdk.out\",\n\"build\": \"tsc\",\n\"watch\": \"tsc -w\",\n\"prepare\": \"npm run-script build\",\n\"test\": \"echo OK\"\n},\n\"devDependencies\": {\n\"@types/node\": \"^12.12.0\",\n\"typescript\": \"~4.0.0\"\n}\n}\n</code></pre></p> <p>Steps Add prettier, husky, lint-staged, and all of the eslint-related packages as dev dependencies. You should look up each package in npmpm to figure out its latest version and use that. To add dependencies, use the following command Amazon: <pre><code> brazil-build app install --save-dev &lt;package&gt;\n</code></pre></p> <p>For this example we will be pulling in the following: <pre><code>{\n\"devDependencies\": {\n\"@types/node\": \"^12.12.0\",\n\"@typescript-eslint/eslint-plugin\": \"^4.4.0\",\n\"@typescript-eslint/parser\": \"^4.4.0\",\n\"eslint\": \"^7.11.0\",\n\"eslint-config-airbnb-typescript\": \"^11.0.0\",\n\"eslint-config-prettier\": \"^6.12.0\",\n\"eslint-plugin-import\": \"^2.22.0\",\n\"eslint-plugin-prettier\": \"^3.1.0\",\n\"husky\": \"^4.3.0\",\n\"lint-staged\": \"^10.4.0\",\n\"prettier\": \"^2.1.0\",\n\"typescript\": \"~4.0.0\"\n}\n}\n</code></pre></p> <p>There\u2019s a lot of ESLint packages, so here\u2019s why each one is important: </p> <ul> <li>@typescript-eslint/parser enables ESLint\u2019s new TypeScript parser,  </li> <li>@typescript-eslint/eslint-plugin enables ESLint plugins which allows ESLint to run prettier formatting with eslint-plugin-prettier,  </li> <li>eslint-config-airbnb-typescript is the one of the most popular ESLint rules package around which we use as a base</li> <li>eslint-config-prettier overrides all ESLint formatting rules that would interfere with prettier making them no-ops</li> <li>eslint-plugin-import is required to be installed by the Airbnb package.</li> </ul> <pre><code>brazil-build app install --save-dev @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint eslint-config-airbnb-typescript eslint-config-prettier eslint-plugin-import eslint-plugin-prettier husky lint-staged prettier\n</code></pre> <p>NPM TODO</p> <p>Setup the eslintrc file in root directory: - Checkout the sample</p> <p>Update your package.json\u2019s scripts. You\u2019ll need to add new scripts and modify the prepare script.</p> <pre><code>{\n\"scripts\": {\n\"clean\": \"rm -rf dist &amp;&amp; rm -rf cdk.out\",\n\"build\": \"tsc\",\n\"watch\": \"tsc -w\",\n\"lint-fix\": \"eslint --fix lib/\",\n\"prepare\": \"npm run lint-fix &amp;&amp; npm run build\",\n\"test\": \"echo OK\"\n}\n}\n</code></pre> <ul> <li>Configure Husky to add a git pre-commit hook which triggers lint-staged. </li> <li>Configure lint-staged to run eslint --fix on all staged files when you run git commit command. You can do this by adding the following to the top-level of your package.json file.</li> </ul> <pre><code>{\n\"husky\": {\n\"hooks\": {\n\"pre-commit\": \"lint-staged\"\n}\n},\n\"lint-staged\": {\n\"lib/**/*.ts\": [\n\"eslint --fix\",\n\"git add\"\n]\n}\n}\n</code></pre> <p>On git commit, lint-staged will look through git\u2019s staged files, match that against lib/*/.ts , then runs eslint --fix  . If that passes, then it runs git add  and proceeds with the commit. If it fails, then the commit fails and your staged files will be unaffected. <p>Checkpoint: </p> <p>In the end your package.json file from above would have its scripts, devDependencies, husky, and lint-staged blocks looking like this:</p> <pre><code>{\n\"scripts\": {\n\"clean\": \"rm -rf dist &amp;&amp; rm -rf cdk.out\",\n\"build\": \"tsc\",\n\"watch\": \"tsc -w\",\n\"lint-fix\": \"eslint --fix lib/\",\n\"prepare\": \"npm run lint-fix &amp;&amp; npm run build\",\n\"test\": \"echo OK\"\n},\n\"devDependencies\": {\n\"@types/node\": \"^12.12.0\",\n\"@typescript-eslint/eslint-plugin\": \"^4.4.0\",\n\"@typescript-eslint/parser\": \"^4.4.0\",\n\"eslint\": \"^7.11.0\",\n\"eslint-config-airbnb-typescript\": \"^11.0.0\",\n\"eslint-config-prettier\": \"^6.12.0\",\n\"eslint-plugin-import\": \"^2.22.0\",\n\"eslint-plugin-prettier\": \"^3.1.0\",\n\"husky\": \"^4.3.0\",\n\"lint-staged\": \"^10.4.0\",\n\"prettier\": \"^2.1.0\",\n\"typescript\": \"~4.0.0\"\n},\n\"husky\": {\n\"hooks\": {\n\"pre-commit\": \"lint-staged\"\n}\n},\n\"lint-staged\": {\n\"lib/**/*.ts\": [\n\"eslint --fix\",\n\"git add\"\n]\n}\n}\n</code></pre> <p>Setup intelliJ - see picture</p> <p>Override prettier config - many ways - One way is using a base prettier object in your package.json file. For example, to increase the max line length of your code to 120 characters, add the following JSON object to your package.json file: <pre><code>{\n\"prettier\": {\n\"printWidth\": 120\n}\n}\n</code></pre></p> <ul> <li>A full list of configuration options can be found in Prettier\u2019s documentation: https://prettier.io/docs/en/options.html</li> </ul> <p>TODO:  Differennce between dependencies and devDependencies</p> <p>ref: https://w.amazon.com/bin/view/Users/skkrail/CDKTypeScriptPackageBestPractices/#MXd9CA6PNH0</p>"},{"location":"languages-and-frameworks/linting-formatting/sample%20eslintrc/","title":"Sample eslintrc","text":"<pre><code>module.exports = {\n// Specifies this is the top-most directory with ESLint configs\nroot: true,\n// Use the TypeScript ESLint parser (@typescript-eslint/parser)\nparser: \"@typescript-eslint/parser\",\nextends: [\n// One of the most popular ESLint rule package\n\"airbnb-typescript/base\",\n// Allows ESLint to run prettier as if it's just another check\n\"plugin:prettier/recommended\",\n],\n// plugins: [\n//   \"import\",\n// ],\n// Required to be specified by some rules\nparserOptions: {\nproject: \"./tsconfig.json\",\n},\nrules: {\n// Don't enforce use of a default export for files with a single export\n\"import/prefer-default-export\": \"off\",\n// Allow console logging\n\"no-console\": \"off\",\n// Allow using new for creating CDK constructs\n\"no-new\": \"off\",\n// Allow for of syntax\n// Source:\n// https://github.com/airbnb/javascript/blob/3dcc59112308211b6ac8478a4ad997ed3f17d9b1/packages/eslint-config-airbnb-base/rules/style.js#L345-L348\n// Debate: https://github.com/airbnb/javascript/issues/1271\n\"no-restricted-syntax\": [\n\"error\",\n{\nselector: \"ForInStatement\",\nmessage: \"for..in loops iterate over the entire prototype chain, which is virtually never what you want. Use Object.{keys,values,entries}, and iterate over the resulting array.\",\n},\n{\nselector: \"LabeledStatement\",\nmessage: \"Labels are a form of GOTO; using them makes code confusing and hard to maintain and understand.\",\n},\n{\nselector: \"WithStatement\",\nmessage: \"`with` is disallowed in strict mode because it makes code impossible to predict and optimize.\",\n},\n],\n},\n// ESLint doesn't let us specify a path, so instead ignore non-source paths\nignorePatterns: [\n\"/build/**\",\n\"/dist/**\",\n\"/node_modules/**\",\n\".eslintrc.js\",\n],\n};\n</code></pre>"},{"location":"languages-and-frameworks/react-js/Intro/","title":"ReactJs Quick Start","text":""},{"location":"languages-and-frameworks/react-js/Intro/#components","title":"Components","text":"<ul> <li>A component is a peice of the UI that contains its own logic</li> <li>JavaScript functions that return markup</li> <li>React component names must always start with a capital letter</li> </ul> <p><pre><code>function MyButton() {\nreturn (\n&lt;button&gt;I'm a button&lt;/button&gt;\n);\n}\n</code></pre> - Now I can use this component in another component <pre><code>export default function MyApp() {\nreturn (\n&lt;div&gt;\n&lt;h1&gt;Welcome to my app&lt;/h1&gt;\n&lt;MyButton /&gt;\n&lt;/div&gt;\n);\n}\n</code></pre></p>"},{"location":"languages-and-frameworks/react-js/Intro/#styles","title":"Styles","text":""},{"location":"languages-and-frameworks/react-js/Intro/#using-css-classnames","title":"Using CSS classNames","text":"<p><pre><code>&lt;img className=\"avatar\" /&gt;\n</code></pre> - In a CSS file: <pre><code>/* In your CSS */\n.avatar {\nborder-radius: 50%;\n}\n</code></pre></p>"},{"location":"languages-and-frameworks/react-js/Intro/#states-vs-props","title":"States vs Props","text":"<p>States and props are the two types of models in react</p>"},{"location":"languages-and-frameworks/react-js/Intro/#states","title":"States","text":"<ul> <li>Acts as a components memory</li> <li>Keep track of information and change it in response to interactions</li> <li>For example: a button keeping track of <code>isHovered</code> state</li> </ul>"},{"location":"languages-and-frameworks/react-js/Intro/#props","title":"Props","text":"<ul> <li>Arguments you pass to a function</li> <li>Parents will pass props to child components</li> <li>For example: A <code>Form</code> component passing a <code>color</code> prop to a button</li> </ul>"},{"location":"languages-and-frameworks/react-native/Intro/","title":"React Native Quick Start","text":""},{"location":"principles/single-responsibility/","title":"Single-responsibility principle","text":"<p>TBD</p>"},{"location":"system-design/content-delivery-network/","title":"Content Delivery Network (CDN)","text":"<p> Source: https://github.com/donnemartin/system-design-primer#content-delivery-network</p> <ul> <li>Globally distributed network of proxy servers, serving content from locations closer to the user such as images/videos</li> <li>The site's DNS resolution will tell clients which server to contact.</li> <li> <p>Can significantly improve performance in two ways:</p> <ul> <li>Users receive content from data centers close to them</li> <li>Your servers do not have to serve requests that the CDN fulfills</li> </ul> </li> <li> <p>Disadvantages:</p> <ul> <li>CDN costs could be significant depending on traffic</li> <li>Content might be stale if it is updated before the TTL expires it.</li> <li>CDNs require changing URLs for static content to point to the CDN.</li> </ul> </li> </ul>"},{"location":"system-design/start-here/","title":"Quick Start","text":"<p>https://github.com/donnemartin/system-design-primer</p>"},{"location":"system-design/start-here/#steps-to-approaching-a-question","title":"Steps to Approaching a Question","text":""},{"location":"system-design/start-here/#1-gather-requirements-and-scope-the-problem","title":"1. Gather requirements and scope the problem","text":"<ul> <li>Who's using it?</li> <li>How are they using it?</li> <li>How many are using it?</li> </ul> <p>### 2. Create a high level design  - Sketch out all the components</p> <p>### 3. Design core components  - Dive into each component of the previous step with more details</p> <p>### 4. Scale  - Load balancer  - Horizontal &amp; Vertical scaling    - Horizontal is adding more machines to existing pool of resources (\"Scaling out\")    - Vertical is adding more power (CPU, RAM) to an existing machine (\"Scaling Up\") [Usually easier and cheaper] - Caching - Database sharding   - Splits a single dataset into partitions (shards)   - Each shard contains unique rows of information that you can store separately across multiple computers, called nodes.    - All shards run on separate nodes but share the original database's schema or design.</p>"},{"location":"system-design/start-here/#5","title":"5.","text":""}]}